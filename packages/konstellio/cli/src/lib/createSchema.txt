import { DocumentNode, DefinitionNode, Kind, ObjectTypeDefinitionNode, DirectiveNode, FieldDefinitionNode, ArgumentNode, ValueNode, TypeNode } from "graphql";

export interface Union {
	handle: string;
	collections: Collection[];
}

export interface Collection {
	handle: string;
	fields: Field[];
	indexes: Index[];
}

export interface Field {
	handle: string;
	type: string;
	isRequired?: true;
	isLocalized?: true;
	isRelation?: true;
	isList?: true;
	isInlined?: true;
	isComputed?: true;
}

export interface Index {
	handle: string;
	type: string;
	fields: { field: string, direction: 'asc' | 'desc' }[];
}

export function createSchema(document: DocumentNode): (Collection | Union)[] {
	return document.definitions.reduce((collections, node) => {
		if (isCollection(node)) {
			const collection = transformDocumentNodeToCollection(document, node);
			if (collection) {
				collections.push(collection);
			}
		}
		return collections;
	}, [] as (Collection | Union)[]);
}

function isCollection(node: DefinitionNode): boolean {
	return (node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION) &&
		node.directives !== undefined &&
		node.directives!.find(d => d.name.value === 'collection') !== undefined;
}

function transformDocumentNodeToCollection(document: DocumentNode, node: DefinitionNode): Collection | Union | undefined {
	if (node.kind === Kind.OBJECT_TYPE_DEFINITION) {
		return {
			handle: node.name.value,
			indexes: transformDirectivesToIndexes(node.directives, node.fields),
			fields: transformFieldsToFields(node.fields)
		};
	}
	else if (node.kind === Kind.UNION_TYPE_DEFINITION) {
		return {
			handle: node.name.value,
			collections: (node.types || []).reduce((collections, type) => {
				const typeNode = getDefNodeByNamedType(document, type.name.value) as ObjectTypeDefinitionNode;
				if (typeNode) {
					const collection = transformDocumentNodeToCollection(document, typeNode);
					if (collection) {
						collections.push(collection as Collection);
					}
				}
				return collections;
			}, [] as Collection[])
		};
	}
}

function transformDirectivesToIndexes(directives: ReadonlyArray<DirectiveNode> | undefined, fields: ReadonlyArray<FieldDefinitionNode> | undefined): Index[] {
	return (directives || []).reduce((indexes, directive) => {
		if (directive.name.value === 'collection') {
			const args = getArgumentsValues(directive.arguments);
			indexes.push(...(args.indexes || []));
		}
		return indexes;
	}, [] as Index[]);
}

function transformFieldsToFields(fields: ReadonlyArray<FieldDefinitionNode> | undefined): Field[] {
	return (fields || []).reduce((fields, field) => {
		const directives = field.directives || [];
		const isRequired = isNonNullType(field.type);
		const isComputed = directives.find(directive => directive.name.value === 'computed') !== undefined;
		const isInlined = directives.find(directive => directive.name.value === 'inlined') !== undefined;
		const isList = isListType(field.type);
		const isLocalized = directives.find(directive => directive.name.value === 'localized') !== undefined;

		const type = getNamedTypeNode(field.type);
		fields.push({
			type,
			handle: field.name.value,
			...(isRequired ? { isRequired: true } : { }),
			...(isLocalized ? { isLocalized: true } : { }),
			...(!isSpecifiedScalarType(type) ? { isRelation: true } : { }),
			...(isList ? { isList: true } : { }),
			...(isInlined ? { isInlined: true } : { }),
			...(isComputed ? { isComputed: true } : { })
		});

		return fields;
	}, [] as Field[]);
}

function getNamedTypeNode(type: TypeNode): string {
	if (type.kind === Kind.NAMED_TYPE) {
		return type.name.value;
	}
	return getNamedTypeNode(type.type);
}

function isSpecifiedScalarType(type: string): boolean {
	return type === 'ID'
		|| type === 'String'
		|| type === 'Int'
		|| type === 'Float'
		|| type === 'Boolean'
		|| type === 'Date'
		|| type === 'DateTime'
		|| type === 'Cursor';
}

function getArgumentsValues(nodes: ReadonlyArray<ArgumentNode> | undefined): { [key: string]: any } {
	if (nodes === undefined) return {};
	return nodes.reduce((args, arg) => {
		args[arg.name.value] = getValue(arg.value);
		return args;
	}, {} as { [name: string]: any });
}

function getValue(node: ValueNode): any {
	if (node.kind === Kind.VARIABLE) {
		return null;
	}
	else if (node.kind === Kind.LIST) {
		return node.values.map(getValue);
	}
	else if (node.kind === Kind.OBJECT) {
		return node.fields.reduce((obj, field) => {
			obj[field.name.value] = getValue(field.value);
			return obj;
		}, {} as { [name: string]: any });
	}
	else if (node.kind === Kind.NULL) {
		return null;
	}
	else {
		return node.value;
	}
}

function isNonNullType(type: TypeNode): boolean {
	if (type.kind === Kind.NON_NULL_TYPE) {
		return true;
	}
	else if (type.kind === Kind.LIST_TYPE) {
		return isNonNullType(type.type);
	}
	return false;
}

function isListType(type: TypeNode): boolean {
	if (type.kind === Kind.LIST_TYPE) {
		return true;
	}
	else if (type.kind === Kind.NON_NULL_TYPE) {
		return isListType(type.type);
	}
	return false;
}

function getDefNodeByNamedType(document: DocumentNode, name: string): DefinitionNode | undefined {
	return document.definitions.find((def: any) => def.name && def.name.value === name);
}